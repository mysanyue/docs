## keep-alive 组件有什么作用

- keep-alive 是 vue 的内置组件，而这个组件的作用就是能够缓存不活动的组件。一般情 况下，组件进行切换的时候，默认是会进行销毁的，如果我们有需求，在某个组件切换后 不进行销毁，而是保存之前的状态，那么就可以利用 keep-alive 来实现。
- 在 keep-alive 上有两个属性，可以对字符串或正则表达式进行匹配，匹配到的组件会被缓存。
- include 值为字符串或者正则表达式匹配的组件 name 会被缓存。（缓存匹配到的组件） exclude 值为字符串或正则表达式匹配的组件 name 不会被缓存。（排除匹配到的组件） 其拥有两个独立的生命周期钩子函数 actived 和 deactived，使用 keep-alive 包裹的组 件在切换时不会被销毁，而是缓存到内存中并执行 deactived 钩子函数，命中缓存渲染后 会执行 actived 钩子函数。

## 说下 vue 生命周期钩子函数

每个 vue 实例在被创建时都要经过一系列的初始化过程。<br>
所有的生命周期钩子自动绑定 this 上下文到实例中，因此可以在函数中访问数据，对属性 和方法进行运算。这意味着不能使用箭头函数来定义一个生命周期方法【这是因为箭头函 数绑定了父上下文，因此 this 与你期待的 Vue 实例不同】。

**阶段一 Vue 实例创建阶段**

- beforeCreate
  Vue 实例在内存中刚被创建，this 变量还不能使用，数据对象（data）和方法（methods） 未初始化，watcher 中的事件都不能获得到；
- created 实例已经在内存中创建好，数据和方法已经初始化完成，但是模板还未编译，页面还是没 有内容，还不能对 dom 节点进行操作（此时访问 this.$el 和 this.$refs.xxx 都是 undefined）
- beforeMounte 找到对应的 template 模板，编译成 render 函数，转换成虚拟 dom，此时模板已经编 译完成，数据未挂载到页面，也就是说在这个阶段你可以看到标签间的双花括号，数据还 未渲染到页面中；<br>
  在 beforeMounte 之后和 mounted 之前，还有渲染 render 函数，它的作用是把模板 渲染成虚拟 dom。
- mounted 模板编译好了，虚拟 dom 渲染成真正的 dom 标签，数据渲染到页面，此时 Vue 实例已 经创建完毕，如果没有其他操作的话，Vue 实例会静静的躺在内存中，一动不动。
  一般会在 mounted 中来渲染从后端获取的数据。(页面初始化时，如果有操作 dom 的 事件一般也会放在 mounted 钩子函数中。当然，也可以放在 create 中，前提需使用 this.\$nextTick(function(){})，在回调函数中操作 dom。)

**阶段二：Vue 实例运行阶段**

- beforeUpdate 数据依赖改变或者用 \$forceUpdata 强制刷新时，对象 data 中的数据已经更改（虚拟 dom 已经重新渲染），但是 页面中的值还是原来，未改变，因为此时还未开始渲染 dom；
- update 此时 data 中的数据和页面更新完毕，页面已经被重新渲染。在实际开发中，一般会用监听器 watch 来代替上边 2 个方法，因为 watch 会知道是哪一 个数据变化。

**阶段三：Vue 实例销毁阶段**

- beforeDestroy 实例销毁前使用，在此刻实例还是可用的。
- destroyed Vue 实例被销毁，观察者、子组件、事件监听被清除（页面数据不会消失，只不过是响应 式无效了）。

## vue 组件中 data 必须是一个函数

如果 data 是一个对象，当复用组件时，因为 data 都会指向同一个引用类型地址，其中 一个组件的 data 一旦发生修改，则其他重用的组件中的 data 也会被一并修改。<br>
如果 data 是一个返回对象的函数，因为每次重用组件时返回的都是一个新对象，引用地 址不同，便不会出现如上问题。

## Vue 中 v-if 和 v-show 有什么区别

v-if 在进行切换时，会直接对标签进行创建或销毁，不显示的标签不会加载在 DOM 树中。 v-show 在进行切换时，会对标签的 display 属性进行切换，通过 display 不显示来隐藏 元素。<br>
一般来说，v-if 的性能开销会比 v-show 大，切换频繁的标签更适合使用 v-show。

## Vue 中 computed 和 watch 有什么区别

**计算属性 computed：**

- 支持缓存，只有依赖数据发生变化时，才会重新进行计算函数；
- 计算属性内不支持异步操作；
- 计算属性的函数中都有一个 get(默认具有，获取计算属性)和 set(手动添加，设置计算属 性)方法；
- 计算属性是自动监听依赖值的变化，从而动态返回内容。

**侦听属性 watch：**

- 不支持缓存，只要数据发生变化，就会执行侦听函数；
- 侦听属性内支持异步操作；
- 侦听属性的值可以是一个对象，接收 handler 回调，deep，immediate 三个属性；
- 监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些其他事情。

## Vue-router 路由有哪些模式

**一般有两种模式：**

hash 模式：后面的 hash 值的变化，浏览器既不会向服务器发出请求，浏览器也不会刷新，每次 hash 值的变化会触发 hashchange 事件。<br>
history 模式：利用了 HTML5 中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。

## Vue-cli 项目中 assets 和 static 文件夹有什么区别

两者都是用于存放项目中所使用的静态资源文件的文件夹。其区别在于：assets 中的文件在运行 npm run build 的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到 static 中。static 中的文件则不会被打包。
