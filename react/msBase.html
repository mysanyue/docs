<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 基础一 | 三月风-整理的面试题</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="海阔凭鱼跃，山高任鸟飞">
    <meta name="author" content="三月风">
    <meta name="keywords" content="vuepress 三月风，的文档笔记">
    
    <link rel="preload" href="/assets/css/0.styles.7841ddca.css" as="style"><link rel="preload" href="/assets/js/app.b50306bc.js" as="script"><link rel="preload" href="/assets/js/2.bd273a66.js" as="script"><link rel="preload" href="/assets/js/15.ad61a1cf.js" as="script"><link rel="preload" href="/assets/js/3.3659927b.js" as="script"><link rel="prefetch" href="/assets/js/10.6d4cafc1.js"><link rel="prefetch" href="/assets/js/11.44eaddcc.js"><link rel="prefetch" href="/assets/js/12.7c868b61.js"><link rel="prefetch" href="/assets/js/13.10be3d6e.js"><link rel="prefetch" href="/assets/js/14.1a0a09bc.js"><link rel="prefetch" href="/assets/js/16.97723887.js"><link rel="prefetch" href="/assets/js/17.e5c5e747.js"><link rel="prefetch" href="/assets/js/18.780f8e34.js"><link rel="prefetch" href="/assets/js/19.4c1ef670.js"><link rel="prefetch" href="/assets/js/20.53af6160.js"><link rel="prefetch" href="/assets/js/21.f8b415ed.js"><link rel="prefetch" href="/assets/js/22.fd619030.js"><link rel="prefetch" href="/assets/js/23.9d210d87.js"><link rel="prefetch" href="/assets/js/24.152afd42.js"><link rel="prefetch" href="/assets/js/25.5697301b.js"><link rel="prefetch" href="/assets/js/26.eb5a3a52.js"><link rel="prefetch" href="/assets/js/27.296a5b84.js"><link rel="prefetch" href="/assets/js/28.c6f796a2.js"><link rel="prefetch" href="/assets/js/29.3f7aba88.js"><link rel="prefetch" href="/assets/js/30.6854eb4e.js"><link rel="prefetch" href="/assets/js/31.e9b26028.js"><link rel="prefetch" href="/assets/js/32.f68f3a53.js"><link rel="prefetch" href="/assets/js/33.1761b514.js"><link rel="prefetch" href="/assets/js/34.17e2e48b.js"><link rel="prefetch" href="/assets/js/35.8a066a9c.js"><link rel="prefetch" href="/assets/js/36.fc0d1848.js"><link rel="prefetch" href="/assets/js/37.d5388dd7.js"><link rel="prefetch" href="/assets/js/38.851c1288.js"><link rel="prefetch" href="/assets/js/4.2c0e1b26.js"><link rel="prefetch" href="/assets/js/5.44ef7197.js"><link rel="prefetch" href="/assets/js/6.a9c2280f.js"><link rel="prefetch" href="/assets/js/7.c5d64862.js"><link rel="prefetch" href="/assets/js/8.445740d2.js"><link rel="prefetch" href="/assets/js/9.457f3120.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7841ddca.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">三月风-整理的面试题</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/web/html/htmlBase1/" class="nav-link">
  Web
</a></div><div class="nav-item"><a href="/node/msBase/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/react/msBase/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/vue/core/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/wechat/ms1/" class="nav-link">
  Wechat
</a></div><div class="nav-item"><a href="/suanf/base/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/performance/base/" class="nav-link">
  网络相关
</a></div><div class="nav-item"><a href="/selfExamin/" class="nav-link">
  自学考试
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/web/html/htmlBase1/" class="nav-link">
  Web
</a></div><div class="nav-item"><a href="/node/msBase/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/react/msBase/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/vue/core/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/wechat/ms1/" class="nav-link">
  Wechat
</a></div><div class="nav-item"><a href="/suanf/base/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/performance/base/" class="nav-link">
  网络相关
</a></div><div class="nav-item"><a href="/selfExamin/" class="nav-link">
  自学考试
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Node.js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/node/msBase.html" class="sidebar-link">Node 基础</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="react-中的-key-是什么-有什么作用"><a href="#react-中的-key-是什么-有什么作用" class="header-anchor">#</a> React 中的 key 是什么，有什么作用</h2> <p>key 是 react 在渲染一系列相同类型的兄弟元素时，给每个元素指定一个稳定、可预测、兄 弟间唯一的值，来帮助 React 识别哪些元素改变了，比如添加和删除，这样做可以避免在 某些场景下的错误渲染并且提升 React 的渲染性能<br>
key 的作用是用在使用 diff 算法对比 react 更新前后两棵树的比较时使用的，使得树的转 换效率得以提高，组件实例基于它们的 key 来决定是否更新以及复用</p> <h2 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h2> <p>组件间通信也就是两个或多个组件之间相互传递消息。从关系上来划分：</p> <ul><li>父级向子级传递信息</li> <li>子级向父级传递信息</li> <li>同级之间传递信息</li> <li>跨组件传递信息</li></ul> <p>React 是一种单向数据流的设计，也就是说信息只能从父级向子级一层一层向下传递</p> <ol><li>父级向子级进行通信：这种信息传递比较简单，父组件在调用子组件时，只需要把想传 递的数据加在子组件的属性上，然后在子组件内部通过 props 属性来接收就可以了。之后， 每次 props 属性发生变化，子组件都会重新进行渲染的</li> <li>子组件向父组件传递信息：React 是单向数据流，没有办法从子组件直接传递信息到父 组件，但是可以在父组件上定义好回调后，把回调函数通过 props 属性传递给子组件，利 用回调向父组件传递信息</li> <li>同级组件之间的信息传递：通过状态提升，将信息共同保存在父组件中，在通过回调函 数更改信息后在用 props 传递给子组件</li> <li>跨层级组件通信：利用高级 API-context 上下文的方式，这里直接转到我的另外一篇博 客里面有详细介绍 React 高级 API-Context</li> <li>Redux、React-redux 等状态管理库结合异步请求处理 redux-thunk、redux-saga</li></ol> <h2 id="react-合成事件机制"><a href="#react-合成事件机制" class="header-anchor">#</a> React 合成事件机制</h2> <p>React 中有自己的事件系统模式，通常被称为 React 合成事件。之所以采用这种自己定义 的合成事件，一方面是为了抹平事件在不同平台体现出来的差异性，这使得 React 开发者 不需要自己再去关注浏览器事件兼容性问题；另一方面是为了统一管理事件，提高性能， 这主要体现在 React 内部实现事件委托，并且记录当前事件发生的状态上<br>
事件委托，也就是我们通常提到的事件代理机制，这种机制不会把事件处理函数直接绑定 在真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件监听和处 理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当 事件放生时，首先被这个统一的事件监听器处理，然后在映射表里找到真正的事件处理函 数并调用。这样做简化了事件处理和回收机制。效率也有很大的提升<br>
记录当前事件发生的状态，即记录事件执行的上下文，这便于 React 来处理不同事件的优 先级，达到谁优先级高先处理谁的目的，这里也就实现了 React 的增量渲染思想，可以预 防掉帧，同时达到页面更加顺滑的目的，提升用户体验</p> <h2 id="细读-setstate"><a href="#细读-setstate" class="header-anchor">#</a> 细读 setState</h2> <blockquote><p>setState(updater, [callback])</p></blockquote> <p>其将对组件的 state 的更改排入队列，并通知 React 需要使用更新后的 state 重新渲此组件 及其子组件。这是用于更新用户界面以及响应事件处理器和处理服务器数据的主要方式 React 会延迟调用 setState，然后通过一次传递更新多个组件，不会保证 state 的变更立即 生 效 ， 如 果 要 立 即 拿 到 this.state 的 值 ， 可 以 在 其 回 调 函 数 callback 或 者 componentDidUpdate 里取到最新的值</p> <p>参数 updater 有两种形式：</p> <p>第一种是函数形式 <code>this.setState((state, props) =&gt; stateChange)</code>
第二种是对象形式，会进行批量更新，如果要使用前一次的 state 值，请使用函数形式 <code>this.setState({value:2})</code></p> <p>setState 中的异步与同步：</p> <p>异步是指批量更新，达到性能优化的目的，在合成事件和生命周期中都是异步的，不能立 马拿到 this.state 的值<br>
同步是指立马能拿到最新的 this.state 值，在定时器 setTimeout 和原生事件中是同步的， 另外在其第二个参数回调函数 callback 中和 componentDidUpdate 更新生命周期函数中 也能得到最新的 this.state 值</p> <h2 id="函数组件与-class-组件如何选择"><a href="#函数组件与-class-组件如何选择" class="header-anchor">#</a> 函数组件与 class 组件如何选择</h2> <ol><li><p>hook 之前的函数组件是什么样子 无状态、无副作用，只能做单纯的展示组件</p></li> <li><p>class 组件有什么弊端，为什么要引入 hook</p> <ul><li>在组件之间复用状态逻辑很难</li> <li>复杂组件变得难以理解</li> <li>难以理解的 class</li></ul></li> <li><p>引入了 hook 之后的函数组件发生了哪些变化
函数组件可以存储和改变状态值(useState、useReducer)，可以执行副作用(useEffect、 useLayoutEffect)，还可以复用状态逻辑(自定义 hook)</p></li> <li><p>函数组件与 class 组件如何选择
出现以上缺点的情况下都适合使用函数组件，函数组件与 class 组件无缝对接</p></li></ol> <h2 id="react-性能优化方案"><a href="#react-性能优化方案" class="header-anchor">#</a> React 性能优化方案</h2> <ol><li><p>减少不必要渲染，如用 shouldComponentUpdate、PureComponent、React.memo 实现</p></li> <li><p>数据缓存</p> <ul><li>useMemo 缓存参数、useCallback 缓存函数</li> <li>函数、对象尽量不要使用内联形式(如 context 的 value object、refs function)</li> <li>Route 中的内联函数渲染时候使用 render 或者 children，不要使用 component， 当你用 component 的时候，Router 会用指定的组件和 React.createElement 创建一个新 的[React elment]。这意味着当你提供的是一个内联函数的时候，每次创建 render 都会创建一个新的组件。这会导致不再更新已经现有组件，⽽是直接卸载然后再去挂载⼀个新的 组件。因此，当⽤到内联函数的内联渲染时，请使⽤ render 或者 children</li></ul></li></ol> <ul><li>不要滥用功能项，如 context、props 等</li> <li>懒加载，对于长页表分页加载</li> <li>减少 http 请求</li></ul> <h2 id="react-router-路由模式"><a href="#react-router-路由模式" class="header-anchor">#</a> React-router 路由模式</h2> <p>hash 模式（HashRouter）：通过监听 hashchange 事件 ，在回调里拿到 window.location.hash 的值。 hash 就是指 url 尾巴后的 # 号以及后面的字符。<br>
hash 模式原理： 使用 window.location.hash 属性及窗口的 onhashchange 事件，可以实现监听浏览器地 址 hash 值变化，执行相应的 js 切换网页。 hash 指的是地址中#号以及后面的字符，也称 为散列值。</p> <p>history 模式（BrowserRouter）： 利用 history API 实现 url 地址改变，网页内容改变。<br>
history 模式原理： window.history 属性指向 History 对象，它表示当前窗口的浏览历史。 History 对象保 存了当前窗口访问过的所有页面网址。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">2022年7月21日星期四 08:32</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.b50306bc.js" defer></script><script src="/assets/js/2.bd273a66.js" defer></script><script src="/assets/js/15.ad61a1cf.js" defer></script><script src="/assets/js/3.3659927b.js" defer></script>
  </body>
</html>
