<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>面经记录 2022-7 | 三月风-整理的面试题</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="海阔凭鱼跃，山高任鸟飞">
    <meta name="author" content="三月风">
    <meta name="keywords" content="vuepress 三月风，的文档笔记">
    
    <link rel="preload" href="/assets/css/0.styles.7841ddca.css" as="style"><link rel="preload" href="/assets/js/app.03b39971.js" as="script"><link rel="preload" href="/assets/js/2.bd273a66.js" as="script"><link rel="preload" href="/assets/js/16.9536f48a.js" as="script"><link rel="preload" href="/assets/js/3.3659927b.js" as="script"><link rel="prefetch" href="/assets/js/10.6d4cafc1.js"><link rel="prefetch" href="/assets/js/11.44eaddcc.js"><link rel="prefetch" href="/assets/js/12.7c868b61.js"><link rel="prefetch" href="/assets/js/13.10be3d6e.js"><link rel="prefetch" href="/assets/js/14.1a0a09bc.js"><link rel="prefetch" href="/assets/js/15.ad61a1cf.js"><link rel="prefetch" href="/assets/js/17.619a57c7.js"><link rel="prefetch" href="/assets/js/18.b744ecf3.js"><link rel="prefetch" href="/assets/js/19.0e5f527c.js"><link rel="prefetch" href="/assets/js/20.4247c365.js"><link rel="prefetch" href="/assets/js/21.48d46ec9.js"><link rel="prefetch" href="/assets/js/22.325dcd48.js"><link rel="prefetch" href="/assets/js/23.8d688876.js"><link rel="prefetch" href="/assets/js/24.2a285929.js"><link rel="prefetch" href="/assets/js/25.4e1f2bc0.js"><link rel="prefetch" href="/assets/js/26.c6e6040e.js"><link rel="prefetch" href="/assets/js/27.26de3f4a.js"><link rel="prefetch" href="/assets/js/28.af7164d9.js"><link rel="prefetch" href="/assets/js/29.19688c3e.js"><link rel="prefetch" href="/assets/js/30.030dd142.js"><link rel="prefetch" href="/assets/js/31.8815bca9.js"><link rel="prefetch" href="/assets/js/32.c0c5a91c.js"><link rel="prefetch" href="/assets/js/33.42c52a4e.js"><link rel="prefetch" href="/assets/js/34.b063fc19.js"><link rel="prefetch" href="/assets/js/35.298965ef.js"><link rel="prefetch" href="/assets/js/36.062a7769.js"><link rel="prefetch" href="/assets/js/37.1c2f981b.js"><link rel="prefetch" href="/assets/js/38.cd6a8054.js"><link rel="prefetch" href="/assets/js/39.a18c8566.js"><link rel="prefetch" href="/assets/js/4.c8a8f85a.js"><link rel="prefetch" href="/assets/js/5.44ef7197.js"><link rel="prefetch" href="/assets/js/6.a9c2280f.js"><link rel="prefetch" href="/assets/js/7.f5259033.js"><link rel="prefetch" href="/assets/js/8.445740d2.js"><link rel="prefetch" href="/assets/js/9.457f3120.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7841ddca.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">三月风-整理的面试题</span></a> <div class="links"><!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/web/html/htmlBase1/" class="nav-link">
  Web
</a></div><div class="nav-item"><a href="/node/msBase/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/react/msBase/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/vue/core/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/wechat/ms1/" class="nav-link">
  Wechat
</a></div><div class="nav-item"><a href="/suanf/base/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/performance/base/" class="nav-link">
  网络相关
</a></div><div class="nav-item"><a href="/self/ms1/" class="nav-link">
  面经
</a></div><div class="nav-item"><a href="/selfExamin/" class="nav-link">
  自学考试
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/web/html/htmlBase1/" class="nav-link">
  Web
</a></div><div class="nav-item"><a href="/node/msBase/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/react/msBase/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/vue/core/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/wechat/ms1/" class="nav-link">
  Wechat
</a></div><div class="nav-item"><a href="/suanf/base/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/performance/base/" class="nav-link">
  网络相关
</a></div><div class="nav-item"><a href="/self/ms1/" class="nav-link">
  面经
</a></div><div class="nav-item"><a href="/selfExamin/" class="nav-link">
  自学考试
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试经历</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/self/ms1.html" aria-current="page" class="active sidebar-link">面经 2022-07</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/self/ms1.html#esmodule、cmd、amd-区别" class="sidebar-link">ESModule、CMD、AMD 区别</a></li><li class="sidebar-sub-header"><a href="/self/ms1.html#set-和-map-区别" class="sidebar-link">Set 和 Map 区别</a></li><li class="sidebar-sub-header"><a href="/self/ms1.html#weakset-与-weakmap-区别" class="sidebar-link">WeakSet 与 WeakMap 区别</a></li><li class="sidebar-sub-header"><a href="/self/ms1.html#promise-实现" class="sidebar-link">Promise 实现</a></li><li class="sidebar-sub-header"><a href="/self/ms1.html#vue-观察者模式和发布订阅模式-以及异同" class="sidebar-link">Vue 观察者模式和发布订阅模式，以及异同</a></li><li class="sidebar-sub-header"><a href="/self/ms1.html#promise-all-和-promise-race-区别" class="sidebar-link">Promise.all 和 Promise.race 区别</a></li><li class="sidebar-sub-header"><a href="/self/ms1.html#webpack-plugin-和-loader-区别" class="sidebar-link">Webpack plugin 和 loader 区别</a></li><li class="sidebar-sub-header"><a href="/self/ms1.html#原型、原型链" class="sidebar-link">原型、原型链</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="esmodule、cmd、amd-区别"><a href="#esmodule、cmd、amd-区别" class="header-anchor">#</a> ESModule、CMD、AMD 区别</h2> <ul><li><p>AMD 依赖前置 (require.js)</p> <p>引入模块 require([ ],callback)<br>
定义模块 define([],callback)<br>
不论定义模块，还是引入模块时，都会先行引入依赖，再定义/引入模块<br></p></li> <li><p>CMD 依赖就近引入原则(seaJs)
引入模块 (遵循就近原则)<br>
定义模块 define([],callback)<br></p></li> <li><p>CommonJS Node.js 模块引入</p> <p>引入模块 require('模块路径')<br>
定义模块 exports.模块名= function(){ //some code ... }<br></p></li> <li><p>ES6
引入模块 import<br>
定义模块 export、export default<br></p></li></ul> <p><strong>CommonJs 规范介绍</strong></p> <ul><li>NodeJs 默认模块化规范，每个文件是一个模块，有自己的作用域</li> <li>CommonJs 规范采用同步加载方式</li> <li>通过 require 加载模块，module.exports 和 exports 输出模块</li></ul> <p><strong>CommonJs 规范特点</strong></p> <ul><li>所有代码都运行在模块作用域，不会污染全局作用域</li> <li>模块可以加载多次，第一次加载时会运行模块，模块输出结果会被缓存，再次加载时，会从缓存结果中直接读取模块输出结果</li> <li>模块按出现顺序加载</li></ul> <hr> <p><strong>AMD 规范介绍</strong></p> <ul><li>AMD 规范采用异步加载模块，允许指定回调函数</li> <li>Node 模块加载速度快，所以适用于同步加载</li> <li>浏览器环境下，模块需要请求获取，所以适用于异步加载</li> <li>requireJs 是 AMD 的一个具体实现库</li></ul> <p><strong>CMD 规范介绍</strong></p> <ul><li>CMD 整合了 CommonJs 和 AMD 的优点，模块加载是异步的</li> <li>CMD 专门用于浏览器端，seaJS 是 CMD 规范的一个实现</li> <li>AMD 和 CMD 最大的问题是没有通过语法升级解决模块化</li></ul> <hr> <p><strong>ESModule 规范介绍</strong></p> <ul><li>ESModule 设计理念是希望在编译时就确定模块依赖关系及输入输出</li> <li>CommonJs 和 AMD 必须在运行时才能确定依赖和输入输出</li> <li>ESM 通过 import 加载模块，通过 export 输出模块</li></ul> <hr> <p><strong>CommonJs 和 ESModule 规范对比</strong></p> <ol><li>CommonJs 输出的是值的拷贝，ESM 输出的是值的引用</li> <li>CJs 模块是运行时加载，ESM 是编译时输出接口</li> <li>CJs 是单个值导出，ESM 可以导出多个</li> <li>CJS 模块是同步加载，ESM 支持异步加载</li> <li>CJS 的 this 指向当前模块的 module.exports，ESM 的 this 指向 undefined</li> <li>语法不同</li></ol> <table><thead><tr><th>名称</th> <th>AMD</th> <th>CMD</th> <th>CommonJS</th> <th>ESM</th></tr></thead> <tbody><tr><td>加载方式</td> <td>异步</td> <td>异步</td> <td>异步同步</td> <td>同步/异步均支持，取决于采用什么 loader API</td></tr> <tr><td>实现实例</td> <td>RequireJs</td> <td>SeaJs（淘宝）</td> <td>nodeJs</td> <td>JavaScript</td></tr> <tr><td>运行环境</td> <td>浏览器</td> <td>浏览器</td> <td>服务端</td> <td>前后端</td></tr></tbody></table> <h2 id="set-和-map-区别"><a href="#set-和-map-区别" class="header-anchor">#</a> Set 和 Map 区别</h2> <p>Set 对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p> <ul><li>add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。</li> <li>delete(value)：删除某个值，删除成功返回 true，否则返回 false。</li> <li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员。</li> <li>clear()：清除所有成员，没有返回值。</li> <li>size：返回 Set 实例的成员总数。</li></ul> <p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数 Map 可以接受一个数组作为参数。</p> <ul><li>set(key, val): 向 Map 中添加新元素</li> <li>get(key): 通过键值查找特定的数值并返回</li> <li>has(key): 判断 Map 对象中是否有 Key 所对应的值，有返回 true,否则返回 false</li> <li>delete(key): 通过键值从 Map 中移除对应的数据</li> <li>clear(): 将这个 Map 中的所有元素删除</li> <li>size：返回 Map 对象中所包含的键值对个数</li></ul> <p>Map 和 Object 的区别:</p> <ul><li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li> <li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li> <li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li> <li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li></ul> <p><strong>总结</strong></p> <ol><li>Map 是键值对，Set 是值的集合，当然键和值可以是任何的值；</li> <li>Map 可以通过 get 方法获取值，而 set 不能因为它只有值；</li> <li>都能通过迭代器进行 for…of 遍历；</li> <li>Set 的值是唯一的可以做数组去重，Map 由于没有格式限制，可以做数据存储</li> <li>map 和 set 都是 stl 中的关联容器，map 以键值对的形式存储，key=value 组成 pair，是一组映射关系。set 只有值，可以认为只有一个数据，并且 set 中元素不可以重复且自动排序。</li></ol> <h2 id="weakset-与-weakmap-区别"><a href="#weakset-与-weakmap-区别" class="header-anchor">#</a> WeakSet 与 WeakMap 区别</h2> <p><strong>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 区别如下：</strong></p> <ul><li>WeakSet 的成员只能是对象，而不能是其他类型的值</li> <li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用
也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。WeakSet 结构有助于防止内存泄漏。</li> <li>WeakSet 没有 size 属性和 forEach 方法
WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。</li> <li>不支持 clear 方法</li></ul> <p><strong>WeakSet 有以下三个方法：</strong></p> <ul><li>add(value)：向 WeakSet 实例添加一个新成员。</li> <li>delete(value)：清除 WeakSet 实例的指定成员。</li> <li>has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li></ul> <p><strong>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。WeakMap 与 Map 的区别有以下几点：</strong></p> <ul><li>WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名</li> <li>WeakMap 的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内
也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。总之，WeakMap 的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap 结构有助于防止内存泄漏。</li> <li>同 WeakSet 一样，WeakMap 也没有遍历操作，即 (keys()、values()和 entries()方法)
因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。</li> <li>不支持 clear 方法</li></ul> <p><strong>WeakMap 有以下四个个方法：</strong></p> <ul><li>get()：通过键名取值</li> <li>set()：设置键值对</li> <li>has()：判断是否存在</li> <li>delete()：删除一项记录</li></ul> <h2 id="promise-实现"><a href="#promise-实现" class="header-anchor">#</a> Promise 实现</h2> <div class="custom-block warning"><p class="custom-block-title">注意事项</p> <ol><li><p>Promise 就是一个类 在执行这个类的时候，需要传递一个执行器进去，执行器会立即执行</p></li> <li><p>Promise 中有三种状态，分别为：</p> <p>成功 - fulfilled <br>
失败 - rejected <br>
等待 - pending <br></p> <p>pending -&gt; fulfilled <br>
pending -&gt; rejected <br>
一旦状态确定就不可更改 <br></p></li> <li><p>resolve 和 reject 函数是用来更改状态的</p> <p>resolve: fulfilled <br>
reject: rejected <br></p></li> <li><p>then 方法内部做的事情就是判断状态，如果状态是成功，调用成功的回调函数，如果状态是失败，调用失败回调函数，then 方法是被定义在原型对象中的方法</p></li> <li><p>then 成功回调有一个参数，表示成功之后的值，then 失败回调有一个参数，表示失败后的原因</p></li></ol></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span> <span class="token comment">// 等待</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span> <span class="token comment">// 成功</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'rejected'</span> <span class="token comment">// 失败</span>

<span class="token comment">/**
 * 1. 判断 x 的值是普通值还是 promise对象
 * 2. 如果是普通值 直接调用 resolve
 * 3. 如果是 promise 对象，查看 promise 对象返回的结果
 * 4. 再根据 promise 对象返回的结果，决定调用 resolve 还是 reject
 */</span>
<span class="token keyword">function</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span><span class="token parameter">promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Chaining cycle detected for promise #&lt;Promise&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// promise 对象</span>
    <span class="token comment">// x.then(() =&gt; resolve(value), reason =&gt; reject(reason))</span>
    x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 普通值</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 错误捕获处理</span>
<span class="token keyword">function</span> <span class="token function">setTimeoutFn</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> val<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    x <span class="token operator">&amp;&amp;</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
  status <span class="token operator">=</span> <span class="token constant">PENDING</span>
  value <span class="token operator">=</span> <span class="token keyword">undefined</span>
  reason <span class="token operator">=</span> <span class="token keyword">undefined</span>
  successCallback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  failCallBack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resolve<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reject<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token comment">// 将状态更改为成功</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span>
    <span class="token comment">// 保存成功之后的值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
    <span class="token comment">// 判断成功回调是否存在，如果存在，调用</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将状态更改为失败</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token comment">// 将状态更改为失败</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECTED</span>
    <span class="token comment">// 保存失败后的原因</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason
    <span class="token comment">// 判断失败函数是否存在，如果存在，调用</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>failCallBack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>failCallBack<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">successCallback<span class="token punctuation">,</span> failCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理 promise.then().then().then(res =&gt; {}, err =&gt; {}) 的情况</span>
    successCallback <span class="token operator">=</span> successCallback <span class="token operator">?</span> <span class="token function-variable function">successCallback</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> value
    failCallback <span class="token operator">=</span> failCallback
      <span class="token operator">?</span> <span class="token function-variable function">failCallback</span>
      <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> reason
        <span class="token punctuation">}</span>

    <span class="token keyword">let</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这里使用 setTimeout 主要是 promise2 还没初始化好</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 状态判断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">setTimeoutFn</span><span class="token punctuation">(</span>successCallback<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">setTimeoutFn</span><span class="token punctuation">(</span>failCallback<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// 等待 - 处理异步调用情况</span>
          <span class="token comment">// 将成功回调和失败回调存储起来</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeoutFn</span><span class="token punctuation">(</span>successCallback<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>failCallBack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeoutFn</span><span class="token punctuation">(</span>failCallback<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> promise2
  <span class="token punctuation">}</span>

  <span class="token keyword">finally</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> MyPromise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> value<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> MyPromise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">throw</span> reason
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">catch</span><span class="token punctuation">(</span>failCallback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> failCallback<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">static</span> <span class="token function">all</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">function</span> <span class="token function">addData</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
        <span class="token comment">// 解决异步调用问题</span>
        index<span class="token operator">++</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> current <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// promise 对象</span>
          current<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
            <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">addData</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">// 普通对象</span>
          <span class="token function">addData</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">static</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token keyword">return</span> value
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> MyPromise
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">注意</p> <ol><li>这里为什么要定义成箭头函数？<br>
因为 MyPromise 里面调用 resovle 或者 reject 是直接调用的，如果不用箭头函数里面的 this 就指向了 window，用箭头函数的话里面的 this 指向 MyPromise 这个类</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ....</span>
<span class="token punctuation">}</span>

<span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>为什么 then 里面要用 setTimeout？<br>
因为使用 promise2 的时候 new MyPromise 还没有初始化完成，所以需要添加一个计时器（宏任务）让，同步任务先执行完然后 promise2 就初始化好了，就可以正常使用。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeoutFn</span><span class="token punctuation">(</span>successCallback<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeoutFn</span><span class="token punctuation">(</span>failCallback<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeoutFn</span><span class="token punctuation">(</span>successCallback<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>failCallBack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeoutFn</span><span class="token punctuation">(</span>failCallback<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></div> <h2 id="vue-观察者模式和发布订阅模式-以及异同"><a href="#vue-观察者模式和发布订阅模式-以及异同" class="header-anchor">#</a> Vue 观察者模式和发布订阅模式，以及异同</h2> <p><strong>相同点</strong></p> <ol><li>这两种模式都使用了事件池机制（观察者模式中叫观察者列表）</li> <li>两种模式都可以往事件池 / 观察者列表中添加或删除方法/对象</li> <li>在发布通知的时候，其事件池 / 观察者列表中存储的方法/对象都能依次进行相关的操作</li></ol> <p><strong>不同点</strong></p> <ol><li>观察者模式的事件池机制使用的是数组，而发布订阅使用的是对象</li> <li>观察者模式需要创建两个类：目标对象类和观察者类；而发布订阅只需要创建一个类：事件池类</li> <li>观察者模式中添加的是观察者 Watch 类的实例，而发布订阅中添加的是内置类 Function 的实例</li> <li>在添加的时候，观察者模式是只添加对象，而发布订阅在添加的时候还指定了添加方法的类型</li> <li>观察者模式在通知的时候不需要指定类型，而发布订阅需要指定类型</li> <li>观察者模式中，目标对象（观察者列表）发布时，所有观察对象都会进行相应的操作，而发布订阅只会操作指定类型的方法</li></ol> <h2 id="promise-all-和-promise-race-区别"><a href="#promise-all-和-promise-race-区别" class="header-anchor">#</a> Promise.all 和 Promise.race 区别</h2> <p><strong>Pomise.all</strong></p> <p>Promise.all 可以将多个 Promise 实例包装成一个新的 Promise 实例。用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p> <ol><li>它接受一个数组作为参数。</li> <li>数组可以是 Promise 对象，也可以是其它值，只有 Promise 会等待状态改变。</li> <li>当所有的子 Promise 都完成，该 Promise 完成，返回值是全部值的数组。</li> <li>如果有任何一个失败，该 Promise 失败，返回值是第一个失败的子 Promise 的结果。</li></ol> <p>常见使用场景：多个异步结果合并到一起</p> <p><strong>Pomise.race</strong></p> <p>Promse.race 就是赛跑的意思，意思就是说，Promise.race()里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。<br>
Promise.race 在第一个 promise 对象变为 Fulfilled 之后，并不会取消其他 promise 对象的执行。只有先完成的 Promise 才会被 Promise.race 后面的 then 处理。其它的 Promise 还是在执行的，只不过是不会进入到 promise.race 后面的 then 内。</p> <p>常见使用场景：把异步操作和定时器放到一起，如果定时器先触发，认为超时，告知用户</p> <p><strong>Promise.all 和 Promise.race 都是有使用场景的</strong></p> <p>有些时候我们做一个操作可能得同时需要不同的接口返回的数据，这时我们就可以使用 Promise.all。<br>
有时我们比如说有好几个服务器的好几个接口都提供同样的服务，我们不知道哪个接口更快，就可以使用 Promise.race，哪个接口的数据先回来我们就用哪个接口的数据。</p> <h2 id="webpack-plugin-和-loader-区别"><a href="#webpack-plugin-和-loader-区别" class="header-anchor">#</a> Webpack plugin 和 loader 区别</h2> <p>loader: 从字面的意思理解，是加载的意思。由于 webpack 本身只能打包 js 文件，所以，针对 css，图片等格式的文件没法打包，就需要引入第三方的模块进行打包。loader 虽然是扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域，完成压缩，打包，语言翻译。loader 是运行在 NodeJS 中。仅仅只是为了打包，仅仅只是为了打包，仅仅只是为了打包，重要的话说三遍！</p> <p>plugin：也是为了扩展 webpack 的功能，但是 plugin 是作用于 webpack 本身上的。而且 plugin 不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack 提供了很多开箱即用的插件：CommonChunkPlugin 主要用于提取第三方库和公共模块，避免首屏加载的 bundle 文件，或者按需加载的 bundle 文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建 bundle。</p> <ul><li>loader 是文件加载器，能加载资源文件，并对这些文件进行一些处理，如：编译，压缩等。最终打包到指定文件中。</li> <li>plugin 是在 webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机中通过 webpack 提供的 api 改变输出结果。</li> <li>plugin 赋予了 webpack 各种灵活的功能，如打包优化，资源管理，环境变量，注入等，目的是为了解决 loader 无法实现的功能。</li></ul> <p><strong>区别</strong></p> <ul><li>loader 是文件转换器，将 A 文件进行编译形成 B 文件，这里操作的是文件，A.less-&gt;A.css</li> <li>loader 运行在打包文件之前（loader 为在模块加载时的预处理文件）</li> <li>plugin 是扩展器，针对的是 loader 结束后 webpack 打包的整个过程，并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。</li> <li>plugins 在整个编译周期都起作用。</li></ul> <h2 id="原型、原型链"><a href="#原型、原型链" class="header-anchor">#</a> 原型、原型链</h2> <p><strong>原型</strong></p> <p>在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</p> <p><img src="/assets/images/js/prototype.png" alt="prototype"></p> <p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p> <p><strong>原型链</strong></p> <p>在 JavaScript 中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在 JavaScript 中是通过 prototype 对象指向父类对象，直到指向 Object 对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p> <p>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到 Object 对象的原型，Object 对象的原型没有原型，如果在 Object 原型中依然没有找到，则返回 undefined。</p> <p><img src="/assets/images/js/__proto__.png" alt="proto"></p> <p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层 Object 为止。Object 是 JS 中所有对象数据类型的基类(最顶层的类)在 Object.prototype 上没有<strong>proto</strong>这个属性。</p> <p><img src="/assets/images/js/__proto__chain.png" alt="__proto__chain"></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">2022年8月5日星期五 08:38</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.03b39971.js" defer></script><script src="/assets/js/2.bd273a66.js" defer></script><script src="/assets/js/16.9536f48a.js" defer></script><script src="/assets/js/3.3659927b.js" defer></script>
  </body>
</html>
