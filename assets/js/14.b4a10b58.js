(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{376:function(v,_,t){"use strict";t.r(_);var a=t(49),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"js-基本数据类型有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-基本数据类型有哪些"}},[v._v("#")]),v._v(" js 基本数据类型有哪些")]),v._v(" "),t("ul",[t("li",[v._v("字符串 String")]),v._v(" "),t("li",[v._v("数值 Number")]),v._v(" "),t("li",[v._v("布尔 boolean")]),v._v(" "),t("li",[v._v("对象 Object")]),v._v(" "),t("li",[v._v("数组 Array")]),v._v(" "),t("li",[v._v("null")]),v._v(" "),t("li",[v._v("undefined")])]),v._v(" "),t("h2",{attrs:{id:"ajax-如何使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ajax-如何使用"}},[v._v("#")]),v._v(" Ajax 如何使用")]),v._v(" "),t("ol",[t("li",[v._v("创建 XMLHTTPRequest 对象")]),v._v(" "),t("li",[v._v("使用 open 方法创建 http 请求，并设置请求地址")]),v._v(" "),t("li",[v._v("xhr.open(get/post，url，async：true(异步)/false(同步))经常 使用前三个参数")]),v._v(" "),t("li",[v._v("设置发送的数据，用 send 发送请求")]),v._v(" "),t("li",[v._v("注册事件（给 ajax 设置事件）")]),v._v(" "),t("li",[v._v("获取响应并更新页面")])]),v._v(" "),t("h2",{attrs:{id:"如何判断一个数据是-nan"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何判断一个数据是-nan"}},[v._v("#")]),v._v(" 如何判断一个数据是 NaN")]),v._v(" "),t("blockquote",[t("p",[v._v("NaN 非数字 但是用 typeof 检测是 number 类型")])]),v._v(" "),t("ol",[t("li",[v._v("利用 NaN 的定义 用 typeof 判断是否为 number 类型并且判断是否满足 isNan")]),v._v(" "),t("li",[v._v("利用 NaN 是唯一一个不等于任何自身的特点 n !== n")]),v._v(" "),t("li",[v._v("利用 ES6 中提供的 Object.is()方法（判断两个值是否相等）")])]),v._v(" "),t("h2",{attrs:{id:"js-中-null-与-undefined-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-中-null-与-undefined-区别"}},[v._v("#")]),v._v(" Js 中 null 与 undefined 区别")]),v._v(" "),t("p",[v._v("相同点：用 if 判断时，两者都会被转换成 false\n不同点：number 转换的值不同 number（null）为 0 number（undefined） 为 NaN Null 表示一个值被定义了，但是这个值是空值 Undefined 变量声明但未赋值")]),v._v(" "),t("h2",{attrs:{id:"闭包是什么-有什么特性-对页面会有什么影响"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包是什么-有什么特性-对页面会有什么影响"}},[v._v("#")]),v._v(" 闭包是什么？有什么特性？对页面会有什么影响")]),v._v(" "),t("blockquote",[t("p",[v._v("闭包可以简单理解成：定义在一个函数内部的函数。其中一个内部函数 在包含它们的外部函数之外被调用时，就会形成闭包。")])]),v._v(" "),t("p",[t("strong",[v._v("特点：")])]),v._v(" "),t("ol",[t("li",[v._v("函数嵌套函数。")]),v._v(" "),t("li",[v._v("函数内部可以引用外部的参数和变量。")]),v._v(" "),t("li",[v._v("参数和变量不会被垃圾回收机制回收。")])]),v._v(" "),t("p",[t("strong",[v._v("使用：")])]),v._v(" "),t("ol",[t("li",[v._v("读取函数内部的变量。")]),v._v(" "),t("li",[v._v("这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除。")])]),v._v(" "),t("p",[t("strong",[v._v("优点：")])]),v._v(" "),t("ol",[t("li",[v._v("变量长期驻扎在内存中")]),v._v(" "),t("li",[v._v("避免全局变量的污染")]),v._v(" "),t("li",[v._v("私有成员的存在")])]),v._v(" "),t("p",[t("strong",[v._v("缺点：会造成内存泄露")])]),v._v(" "),t("h2",{attrs:{id:"js-中常见的内存泄漏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-中常见的内存泄漏"}},[v._v("#")]),v._v(" Js 中常见的内存泄漏")]),v._v(" "),t("ol",[t("li",[v._v("意外的全局变量")]),v._v(" "),t("li",[v._v("被遗忘的计时器或回调函数")]),v._v(" "),t("li",[v._v("脱离 DOM 的引用")]),v._v(" "),t("li",[v._v("闭包")])]),v._v(" "),t("h2",{attrs:{id:"事件委托是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件委托是什么"}},[v._v("#")]),v._v(" 事件委托是什么")]),v._v(" "),t("blockquote",[t("p",[v._v("如何确定事件源（Event.target 谁调用谁就 是事件源）")])]),v._v(" "),t("p",[v._v("JS 高程上讲：事件委托就是利用事件冒泡，只制定一个时间处理程序， 就可以管理某一类型的所有事件。")]),v._v(" "),t("p",[v._v("事件委托，称事件代理，是 js 中很常用的绑定事件的技巧，事件委托就 是把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事 件监听的职务，事件委托的原理是 DOM 元素的事件冒泡")])])}),[],!1,null,null,null);_.default=e.exports}}]);